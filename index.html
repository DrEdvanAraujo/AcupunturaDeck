<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Você pode adicionar um título genérico aqui ou remover a tag title se este for apenas um fragmento para seu site -->
    <title>Botão Aplicação Acupuntura</title>
    <!-- Adicione links CSS externos se o seu site principal os utiliza (ex: Bootstrap),
         mas os estilos específicos do botão estão incluídos abaixo -->
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <style>

        /* Estilos para o botão específico da aplicação de Acupuntura */
        #launchAcupunctureButton {
            /* Usando classes Bootstrap + personalização se necessário */
            /* padding: 20px 40px; */ /* Exemplo de padding customizado */
            /* font-size: 1.5em; */  /* Exemplo de tamanho customizado */
            margin: 20px auto; /* Adiciona margem acima/abaixo e centraliza horizontalmente se body tiver text-align: center */
            display: block; /* Ajuda na centralização com margin auto */
            width: fit-content; /* Ajusta a largura ao conteúdo */
			background-color: #2a9d8f !important; /* Sua cor amarela/dourada. Use !important para garantir que sobrescreva o Bootstrap */
            border-color: #2a9d8f !important;     /* Mesma cor para a borda */
            color: ##2a9d8f; 
        }
    </style>
</head>
<body>

    <!-- O Botão HTML -->
    <button id="launchAcupunctureButton" class="btn btn-warning btn-lg">
        Abrir Baralho Interativo de Acupuntura
    </button>

    <script>
        // --- Conteúdo HTML/CSS/JS da Aplicação de Acupuntura (string longa) ---
        const acupunctureAppHTML = `
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baralho Interativo de Acupuntura</title>
    <style>
        /* Estilos Gerais e de Controles */
        body { background: #dfece5; font-family: 'Segoe UI', sans-serif; margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center; min-height: 100vh; }
        body.zoomed, body.quiz-active, body.memory-game-active { overflow: hidden; } /* Prevent scroll during overlays */
        .controls { background-color: #ffffff; padding: 15px 20px; border-radius: 15px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); margin-bottom: 30px; display: flex; gap: 15px; align-items: center; flex-wrap: wrap; justify-content: center; z-index: 10; position: relative; }
        .controls label { font-weight: bold; color: #333; }
        .controls select, .controls button { padding: 8px 12px; border-radius: 8px; border: 1px solid #ccc; font-size: 1em; cursor: pointer; background-color: #f8f8f8; transition: background-color 0.3s, box-shadow 0.3s; }
        .controls select:hover, .controls button:hover { background-color: #eee; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .controls button { background-color: #4CAF50; color: white; border-color: #388E3C; }
        .controls button:hover { background-color: #388E3C; }
        #resetBtn { background-color: #f44336; border-color: #d32f2f; }
        #resetBtn:hover { background-color: #c62828; }
        #startQuizBtn { background-color: #2196F3; border-color: #1976D2;}
        #startQuizBtn:hover { background-color: #1976D2; }
        #openMemoryGameBtn { background-color: #ff9800; border-color: #f57c00; } /* Renamed button */
        #openMemoryGameBtn:hover { background-color: #e68900; }

        /* Área de Cartas e Carta Individual (Standard View) */
        #cardDisplayArea { display: flex; flex-wrap: wrap; justify-content: center; gap: 25px; padding: 20px; width: 100%; max-width: 1200px; perspective: 1500px; }
        .scene { width: 220px; height: 300px; perspective: 800px; position: relative; }
        .card { width: 100%; height: 100%; position: relative; transform-style: preserve-3d; transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275); border-radius: 15px; box-shadow: 0 6px 12px rgba(0,0,0,0.15); cursor: pointer; }
        .card.is-flipped { transform: rotateY(180deg); }
        .face { position: absolute; top: 0; left: 0; width: 100%; height: 100%; backface-visibility: hidden; border-radius: 15px; overflow: hidden; display: flex; flex-direction: column; justify-content: center; align-items: center; background: #ffffff; }
        .front { position: relative; padding: 10px; box-sizing: border-box; text-align: center; }
        .back { transform: rotateY(180deg); padding: 0; background: #ffffff; }
        .face > img { display: block; width: 100%; height: 100%; object-fit: contain; border-radius: 15px; }
        .card-name { font-weight: bold; color: #333; font-size: 0.9em; position: absolute; bottom: 10px; left: 0; right: 0; background-color: rgba(255, 255, 255, 0.8); padding: 5px 0; text-align: center; pointer-events: none; z-index: 2; }

        /* Visão Inicial */
        #initialView { display: flex; flex-direction: column; align-items: center; text-align: center; margin-top: 20px; }
        #coverCard { width: 220px; height: 300px; background: url('https://i.postimg.cc/W1DSkD2n/Chat-GPT-Image-10-04-2025-20-46-36.png') center center / cover no-repeat; border-radius: 15px; box-shadow: 0 6px 12px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.1) inset; position: relative; margin-bottom: 10px; border: 5px solid white; }
        #coverCard::before, #coverCard::after { content: ''; position: absolute; width: 95%; height: 100%; background-color: #f0f0f0; border-radius: 15px; box-shadow: 0 6px 12px rgba(0,0,0,0.1); border: 5px solid white; z-index: -1; }
        #coverCard::before { transform: rotate(-3deg) translate(-2px, 2px); top: 0; left: 2.5%; }
        #coverCard::after { transform: rotate(2deg) translate(1px, 4px); top: 0; left: 2.5%; z-index: -2; background-color: #e8e8e8; }
        #initialView p { font-style: italic; color: #555; }

        /* Lupa e Overlay de Zoom */
        .zoom-icon { position: absolute; top: 10px; right: 10px; font-size: 1.5em; cursor: pointer; background-color: rgba(255, 255, 255, 0.7); border-radius: 50%; padding: 2px 5px; line-height: 1; z-index: 5; transition: transform 0.2s ease; }
        .zoom-icon:hover { transform: scale(1.1); }
        #zoomOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); display: none; align-items: center; justify-content: center; z-index: 1000; opacity: 0; transition: opacity 0.3s ease-in-out; }
        #zoomOverlay.visible { display: flex; opacity: 1; }
        #zoomOverlay .scene { width: 70vw; height: 85vh; max-width: 600px; max-height: 800px; transition: transform 0.3s ease-in-out; transform: scale(0.8); }
        #zoomOverlay.visible .scene { transform: scale(1); }
        #zoomOverlay .zoom-icon { font-size: 2em; top: 15px; right: 15px; }

        /* --- Estilos do Modal do Quiz (Unchanged) --- */
        #quizModal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: none; align-items: center; justify-content: center; z-index: 1100; opacity: 0; transition: opacity 0.4s ease-in-out; padding: 20px; box-sizing: border-box; }
        #quizModal.visible { display: flex; opacity: 1; }
        .quiz-container { background-color: #fff; padding: 25px 30px; border-radius: 15px; width: 90%; max-width: 700px; max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.2); position: relative; text-align: center; }
        #closeQuizBtn { position: absolute; top: 10px; right: 15px; background: #ff4d4d; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; font-size: 18px; font-weight: bold; line-height: 28px; cursor: pointer; text-align: center; z-index: 1; }
        #quizQuestion { font-size: 1.3em; margin-bottom: 15px; color: #333; font-weight: bold; min-height: 2.6em; }
        #quizImageContainer { min-height: 10px; }
        #quizImageContainer img { max-width: 80%; max-height: 250px; height: auto; margin-bottom: 20px; border-radius: 10px; border: 1px solid #eee; }
        #quizOptions { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .quiz-option-btn { border: 1px solid #ccc; border-radius: 8px; background-color: #f0f0f0; cursor: pointer; transition: background-color 0.3s, border-color 0.3s; font-size: 0.95em; text-align: center; padding: 10px; display: flex; flex-direction: column; align-items: center; }
        .quiz-option-btn.has-image { min-height: 130px; justify-content: flex-start; }
        .quiz-option-btn.has-image img { max-width: 90%; height: 80px; object-fit: contain; margin-bottom: 8px; border-radius: 5px; display: block; }
        .quiz-option-btn.has-image span { display: block; font-weight: 500; line-height: 1.3; margin-top: auto; padding-top: 5px; }
        .quiz-option-btn.no-image { min-height: auto; justify-content: center; padding: 15px; font-size: 1em; }
         .quiz-option-btn.no-image span { display: inline; margin: 0; padding: 0; font-weight: 500; }
         .quiz-option-btn img:not([src]), .quiz-option-btn img[src=""] { display: none; }
        .quiz-option-btn:hover { background-color: #e0e0e0; border-color: #aaa; }
        .quiz-option-btn.selected { background-color: #add8e6; border-color: #87ceeb; font-weight: bold; }
        .quiz-option-btn.correct { background-color: #90ee90 !important; border-color: #32cd32 !important; color: #006400; }
        .quiz-option-btn.incorrect { background-color: #ffcccb !important; border-color: #ff6347 !important; color: #a52a2a; }
        #quizFeedback { margin-top: 15px; font-size: 1.1em; font-weight: bold; min-height: 1.5em; }
        #quizFeedback.correct { color: green; }
        #quizFeedback.incorrect { color: red; }
        #quizActions button { padding: 10px 20px; border-radius: 8px; border: none; font-size: 1em; cursor: pointer; color: white; margin-top: 10px; min-width: 150px; }
        #confirmAnswerBtn { background-color: #ffc107; color: #333; }
        #confirmAnswerBtn:disabled { background-color: #aaa; cursor: not-allowed; }
        #nextQuestionBtn { background-color: #17a2b8; display: none; }
        #quizScore { margin-top: 15px; font-size: 1.1em; font-weight: bold; color: #555; }
        #quizResults { margin-top: 20px; padding: 20px; background-color: #e9f5e9; border: 1px solid #c8e6c9; border-radius: 10px; }
        #quizResults h3 { color: #2e7d32; margin-bottom: 10px; }
        #quizResults p { font-size: 1.2em; font-weight: bold; }

        /* --- Estilos do Modal do Jogo da Memória --- */
        #memoryGameModal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); display: none; align-items: center; justify-content: center; z-index: 1100; opacity: 0; transition: opacity 0.4s ease-in-out; padding: 20px; box-sizing: border-box; }
        #memoryGameModal.visible { display: flex; opacity: 1; }
        .memory-game-container { background-color: #fff; padding: 20px; border-radius: 15px; width: 90%; max-width: 1000px; /* Default max width */ max-height: 90vh; /* Default max height */ overflow: hidden; /* Hide internal scrollbars initially */ box-shadow: 0 10px 30px rgba(0,0,0,0.25); position: relative; display: flex; flex-direction: column; transition: width 0.3s ease, height 0.3s ease, max-width 0.3s ease, max-height 0.3s ease; }
        .memory-game-container.maximized { width: 95vw; height: 95vh; max-width: none; max-height: none; } /* Maximized styles */
        #closeMemoryGameBtn { position: absolute; top: 10px; right: 15px; background: #ff4d4d; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; font-size: 18px; font-weight: bold; line-height: 28px; cursor: pointer; text-align: center; z-index: 3; }
        #toggleMaximizeMemoryBtn { position: absolute; top: 10px; right: 55px; background: #ccc; color: #333; border: none; border-radius: 5px; width: 30px; height: 30px; font-size: 16px; font-weight: bold; line-height: 28px; cursor: pointer; text-align: center; z-index: 3; }
        #memoryGameHeader { text-align: center; margin-bottom: 5px; /* Reduced margin */ padding-right: 80px; /* Space for buttons */ }
        #memoryGameHeader h2 { margin: 0 0 5px 0; color: #ff9800; }
        #memoryGameInfo { display: flex; justify-content: space-around; align-items: center; font-size: 1.1em; font-weight: bold; color: #555; margin-bottom: 10px; min-height: 25px; } /* Container for status and timer */
        #memoryGameStatus {} /* Styles for status */
        #memoryTimerDisplay { color: #dc3545; } /* Styles for timer */

        #memoryGameSetup { text-align: center; padding: 20px 0; display: flex; flex-direction: column; align-items: center; gap: 15px; }
        #memoryGameSetup label { font-size: 1.1em; font-weight: 500; margin-bottom: 5px; }
        #memoryPairsSelect { padding: 8px 12px; border-radius: 8px; border: 1px solid #ccc; font-size: 1em; min-width: 80px; margin-bottom: 10px; }
        .timer-options { display: flex; gap: 10px; align-items: center; margin-bottom: 15px; flex-wrap: wrap; justify-content: center; }
        .timer-options label { font-weight: normal; display: flex; align-items: center; gap: 5px; cursor: pointer; }
        .timer-options input[type="radio"] { margin: 0; }
        #confirmMemorySetupBtn { background-color: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 8px; font-size: 1em; cursor: pointer; }

        #memoryGameArea { flex-grow: 1; /* Takes remaining space */ display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); /* Adjust minmax for card size */ gap: 10px; padding: 10px; overflow-y: auto; /* Allow scrolling if needed */ justify-items: center; /* Center items within grid cells */ }
        .memory-game-container.maximized #memoryGameArea { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; } /* Slightly larger cards when maximized */

        /* Card styles within the modal grid */
        .memory-scene { width: 100%; /* Take grid cell width */ aspect-ratio: 2 / 3; /* Maintain approx card ratio */ perspective: 600px; position: relative; transition: opacity 0.5s ease-out, transform 0.3s ease-out; /* Added transition for removal */ }
        .memory-scene.matched-fade-out { opacity: 0; transform: scale(0.9); /* Slight shrink effect */ pointer-events: none; /* Prevent interaction during fade */ } /* Style for fading out */

        .memory-card { width: 100%; height: 100%; position: relative; transform-style: preserve-3d; transition: transform 0.6s cubic-bezier(0.4, 0.0, 0.2, 1); border-radius: 8px; box-shadow: 0 3px 6px rgba(0,0,0,0.1); cursor: pointer; border: 2px solid white; }
        .memory-card.is-flipped { transform: rotateY(180deg); }
        .memory-face { position: absolute; top: 0; left: 0; width: 100%; height: 100%; backface-visibility: hidden; border-radius: 6px; overflow: hidden; display: flex; justify-content: center; align-items: center; }
        .memory-front { background: url('https://i.postimg.cc/W1DSkD2n/Chat-GPT-Image-10-04-2025-20-46-36.png') center center / cover no-repeat; background-color: #eee; }
        .memory-back { transform: rotateY(180deg); background: #ffffff; padding: 3px; box-sizing: border-box; }
        .memory-back img { display: block; max-width: 100%; max-height: 100%; object-fit: contain; border-radius: 4px; }

    </style>
</head>
<body>

    <h1>Baralho Interativo de Acupuntura</h1>
    <div class="controls">
        <button id="randomCardBtn">Tirar Carta Aleatória</button>
        <div><label for="conditionSelect">Ou escolha uma condição:</label><select id="conditionSelect"><option value="">-- Selecione --</option></select></div>
        <button id="openMemoryGameBtn">Jogo da Memória</button> <!-- Opens the modal -->
        <button id="startQuizBtn">Iniciar Quiz</button>
        <button id="resetBtn">Resetar</button>
    </div>

    <div id="initialView"><div id="coverCard"></div><p>Selecione uma opção acima para começar.</p></div>
    <div id="cardDisplayArea"></div> <!-- Standard card display -->
    <div id="zoomOverlay"></div>

    <!-- Modal do Quiz (Unchanged) -->
    <div id="quizModal">
        <div class="quiz-container">
            <button id="closeQuizBtn">×</button>
            <h2>Quiz de Acupuntura</h2>
            <div id="quizScore">Pontuação: 0 / 0</div><hr>
            <div id="quizContent">
                <div id="quizQuestion">Carregando pergunta...</div>
                <div id="quizImageContainer"></div>
                <div id="quizOptions"></div>
                <div id="quizFeedback"></div>
                <div id="quizActions">
                     <button id="confirmAnswerBtn" disabled>Confirmar Resposta</button>
                    <button id="nextQuestionBtn">Próxima Pergunta</button>
                </div>
            </div>
            <div id="quizResults" style="display: none;">
                <h3>Quiz Finalizado!</h3>
                <p>Sua pontuação final: <span id="finalScore"></span></p>
                <button id="restartQuizBtn" style="background-color: #4CAF50;">Jogar Novamente</button>
            </div>
        </div>
    </div>

    <!-- Modal do Jogo da Memória -->
    <div id="memoryGameModal">
        <div class="memory-game-container">
            <button id="closeMemoryGameBtn">×</button>
            <button id="toggleMaximizeMemoryBtn" title="Maximizar/Restaurar">□</button> <!-- Maximize Button -->
            <div id="memoryGameHeader">
                 <h2>Jogo da Memória</h2>
                 <div id="memoryGameInfo"> <!-- Combined status and timer -->
                    <div id="memoryGameStatus">Pares Encontrados: 0 / 0</div>
                    <div id="memoryTimerDisplay"></div> <!-- Timer display -->
                 </div>
            </div>
            <hr style="border: none; border-top: 1px solid #eee; margin: 0 0 15px 0;">

            <!-- Setup View -->
            <div id="memoryGameSetup">
                 <label for="memoryPairsSelect">Escolha o número de pares (5-17):</label>
                 <select id="memoryPairsSelect"></select>

                 <label>Tempo Limite:</label> <!-- Timer options -->
                 <div class="timer-options">
                     <label><input type="radio" name="memoryTimer" value="0" checked> Sem Tempo</label>
                     <label><input type="radio" name="memoryTimer" value="120"> 2 min</label>
                     <label><input type="radio" name="memoryTimer" value="300"> 5 min</label>
                     <label><input type="radio" name="memoryTimer" value="600"> 10 min</label>
                 </div>

                 <button id="confirmMemorySetupBtn">Iniciar Jogo</button>
            </div>

            <!-- Game Board Area -->
            <div id="memoryGameArea" style="display: none;">
                 <!-- Memory cards will be generated here by JS -->
            </div>
        </div>
    </div>


    <script>
        // --- Dados das Cartas (Unchanged) ---
        const cardsData = [
    { id: 'PC6', name: 'Neiguan (PC6)', frontImage: 'https://i.postimg.cc/ns99JWBC/PC6.jpg', backImage: 'https://i.postimg.cc/G8Qy7yvQ/VERSO-PC6.jpg' },
    { id: 'LI4', name: 'Hegu (LI4)', frontImage: 'https://i.postimg.cc/XrRdp3Vw/LI4.jpg', backImage: 'https://i.postimg.cc/YGkFz3L0/VERSO-LI4.jpg' },
    { id: 'ST36', name: 'Zusanli (ST36)', frontImage: 'https://i.postimg.cc/gnGhZNFT/ST36.jpg', backImage: 'https://i.postimg.cc/5XY84jM4/VERSO-ST36.jpg' },
    { id: 'SP6', name: 'Sanyinjiao (SP6)', frontImage: 'https://i.postimg.cc/Wh4MyXWJ/SP6.jpg', backImage: 'https://i.postimg.cc/D8Yq3LHp/VERSO-SP6.jpg' },
    { id: 'LR3', name: 'Taichong (LR3)', frontImage: 'https://i.postimg.cc/V0WbhbMg/LR3.jpg', backImage: 'https://i.postimg.cc/MXq07W15/VERSO-LR3.jpg' },
    { id: 'GB20', name: 'Fengchi (GB20)', frontImage: 'https://i.postimg.cc/BP0KNC8t/GB20.jpg', backImage: 'https://i.postimg.cc/Dm6r5tgT/VERSO-GB20.jpg' },
    { id: 'HT7', name: 'Shenmen (HT7)', frontImage: 'https://i.postimg.cc/ph8jDSLg/HT7.jpg', backImage: 'https://i.postimg.cc/34Cgs6Q2/VERSO-HT7.jpg' },
    { id: 'LU7', name: 'Lieque (LU7)', frontImage: 'https://i.postimg.cc/1gF0HXWC/LU7.jpg', backImage: 'https://i.postimg.cc/tZH3mbwX/VERSO-LU7.jpg' },
    { id: 'KI3', name: 'Taixi (KI3)', frontImage: 'https://i.postimg.cc/WdhwdX0P/KI3.jpg', backImage: 'https://i.postimg.cc/TKFqggc5/VERSO-KI3.jpg' },
    { id: 'BL60', name: 'Kunlun (BL60)', frontImage: 'https://i.postimg.cc/t7N5w198/BL60.jpg', backImage: 'https://i.postimg.cc/CzMNgF15/VERSO-BL60.jpg' },
    { id: 'Yintang', name: 'Yintang (Extra)', frontImage: 'https://i.postimg.cc/8FxWfGNR/ex-hn3.jpg', backImage: 'https://i.postimg.cc/Mf5v5J2r/verso-ex-hn3.jpg' },
    { id: 'GV20', name: 'Baihui (GV20)', frontImage: 'https://i.postimg.cc/d7hr03PQ/GV20.jpg', backImage: 'https://i.postimg.cc/7GvGYNnX/VERSO-GV20.jpg' },
    { id: 'LI11', name: 'Quchi (LI11)', frontImage: 'https://i.postimg.cc/MnK1ht9Q/LI11.jpg', backImage: 'https://i.postimg.cc/PpmLL86H/VERSO-LI11.jpg' },
    { id: 'ST25', name: 'Tianshu (ST25)', frontImage: 'https://i.postimg.cc/GHRFjbYz/ST25.jpg', backImage: 'https://i.postimg.cc/rK9Sn7NT/VERSO-ST25.jpg' },
    { id: 'BL23', name: 'Shenshu (BL23)', frontImage: 'https://i.postimg.cc/8JrRZ5tX/BL23.jpg', backImage: 'https://i.postimg.cc/fScxhP4x/VERSO-BL23.jpg' },
    { id: 'GB34', name: 'Yanglingquan (GB34)', frontImage: 'https://i.postimg.cc/t1cddPtV/GB34.jpg', backImage: 'https://i.postimg.cc/sGdpqrLj/VERSO-GB34.jpg' },
    { id: 'LI20', name: 'Yingxiang (LI20)', frontImage: 'https://i.postimg.cc/ts2NT8sk/LI20.jpg', backImage: 'https://i.postimg.cc/V0mJXLTC/VERSO-LI-20.png' }
];
        const clinicalConditions = {
            "Ansiedade": ['PC6', 'HT7', 'Yintang', 'LR3'], "Cefaleia do tipo tensão": ['GB20', 'LI4', 'LR3', 'Yintang'], "Cervicalgia": ['GB20', 'BL60', 'LI4'], "Constipação": ['ST25', 'SP6', 'ST36', 'LI4'], "Depressão": ['GV20', 'HT7', 'PC6', 'LR3', 'Yintang'], "Dor em ombro e cintura escapular": ['LI4', 'LI11', 'GB20'], "Insônia": ['HT7', 'SP6', 'KI3', 'Yintang', 'PC6'], "Lombalgia": ['BL23', 'BL60', 'GB34', 'KI3'], "Osteoartrite de joelho": ['ST36', 'SP6', 'GB34'], "Rinite alérgica": ['LI4', 'LI20', 'GB20', 'LU7']
        };
        const cardImageMap = new Map(cardsData.map(card => [card.name, card.frontImage]));
        const PLACEHOLDER_IMAGE_URL = 'https://via.placeholder.com/80x80/eee/aaa?text=Img';
        const COVER_IMAGE_URL = 'https://i.postimg.cc/W1DSkD2n/Chat-GPT-Image-10-04-2025-20-46-36.png';

        // --- Referências do DOM ---
        const randomCardBtn = document.getElementById('randomCardBtn');
        const conditionSelect = document.getElementById('conditionSelect');
        const cardDisplayArea = document.getElementById('cardDisplayArea');
        const initialView = document.getElementById('initialView');
        const resetBtn = document.getElementById('resetBtn');
        const zoomOverlay = document.getElementById('zoomOverlay');
        const startQuizBtn = document.getElementById('startQuizBtn');
        const openMemoryGameBtn = document.getElementById('openMemoryGameBtn');

        // Quiz DOM Refs (Unchanged)
        const quizModal = document.getElementById('quizModal');
        const closeQuizBtn = document.getElementById('closeQuizBtn');
        const quizContainer = quizModal.querySelector('.quiz-container');
        const quizScoreEl = document.getElementById('quizScore');
        const quizContentEl = document.getElementById('quizContent');
        const quizQuestionEl = document.getElementById('quizQuestion');
        const quizImageContainerEl = document.getElementById('quizImageContainer');
        const quizOptionsEl = document.getElementById('quizOptions');
        const quizFeedbackEl = document.getElementById('quizFeedback');
        const confirmAnswerBtn = document.getElementById('confirmAnswerBtn');
        const nextQuestionBtn = document.getElementById('nextQuestionBtn');
        const quizResultsEl = document.getElementById('quizResults');
        const finalScoreEl = document.getElementById('finalScore');
        const restartQuizBtn = document.getElementById('restartQuizBtn');

        // Memory Game DOM Refs
        const memoryGameModal = document.getElementById('memoryGameModal');
        const memoryGameContainer = memoryGameModal.querySelector('.memory-game-container');
        const closeMemoryGameBtn = document.getElementById('closeMemoryGameBtn');
        const toggleMaximizeMemoryBtn = document.getElementById('toggleMaximizeMemoryBtn');
        const memoryGameStatusEl = document.getElementById('memoryGameStatus');
        const memoryTimerDisplayEl = document.getElementById('memoryTimerDisplay'); // Timer Display Element
        const memoryGameSetup = document.getElementById('memoryGameSetup');
        const memoryPairsSelect = document.getElementById('memoryPairsSelect');
        const confirmMemorySetupBtn = document.getElementById('confirmMemorySetupBtn');
        const memoryGameArea = document.getElementById('memoryGameArea');
        const timerOptionsInputs = document.querySelectorAll('input[name="memoryTimer"]'); // Timer Radio Inputs


        // --- Variáveis de Estado ---
        let quizQuestions = []; let currentQuestionIndex = 0; let score = 0; let selectedAnswer = null; let quizActive = false; const TOTAL_QUIZ_QUESTIONS = 10; const QUESTIONS_PER_TYPE = 5;

        // --- Variáveis de Estado do Jogo da Memória ---
        let isMemoryGameActive = false;
        let flippedMemoryCards = [];
        let matchedPairs = 0;
        let totalMemoryPairs = 0;
        let lockBoard = false;
        let memoryTimerInterval = null; // ID do intervalo do timer
        let memoryTimeLeft = 0;         // Segundos restantes
        let memorySelectedTime = 0;     // Tempo inicial selecionado em segundos

        // --- Funções Principais (Standard Card Display - Unchanged) ---
        function populateConditions() { conditionSelect.innerHTML = '<option value="">-- Selecione --</option>'; for (const condition in clinicalConditions) { const option = document.createElement('option'); option.value = condition; option.textContent = condition; conditionSelect.appendChild(option); } }
        function createCardElement(cardData) { /* ... (unchanged) ... */
             const scene = document.createElement('div'); scene.className = 'scene'; scene.dataset.cardId = cardData.id;
            const card = document.createElement('div'); card.className = 'card';
            card.addEventListener('click', (event) => {
                if (!scene.closest('#zoomOverlay') && !event.target.classList.contains('zoom-icon')) {
                    card.classList.toggle('is-flipped');
                }
            });
            const faceFront = document.createElement('div'); faceFront.className = 'face front';
            const imgFront = document.createElement('img'); imgFront.src = cardData.frontImage; imgFront.alt = \`Frente: \${cardData.name}\`; imgFront.onerror = () => { imgFront.src = PLACEHOLDER_IMAGE_URL; imgFront.alt = 'Erro ao carregar imagem frontal'; };
            const nameFront = document.createElement('div'); nameFront.className = 'card-name'; nameFront.textContent = cardData.name;
            const zoomIcon = document.createElement('span'); zoomIcon.className = 'zoom-icon'; zoomIcon.textContent = '🔍'; zoomIcon.title = 'Ampliar/Reduzir';
            zoomIcon.addEventListener('click', (event) => { event.stopPropagation(); toggleZoom(scene); });
            faceFront.appendChild(imgFront); faceFront.appendChild(nameFront); faceFront.appendChild(zoomIcon);

            const faceBack = document.createElement('div'); faceBack.className = 'face back';
            const imgBack = document.createElement('img'); imgBack.src = cardData.backImage; imgBack.alt = \`Verso: \${cardData.name}\`; imgBack.onerror = () => { imgBack.src = PLACEHOLDER_IMAGE_URL; imgBack.alt = 'Erro ao carregar imagem do verso'; };
            faceBack.appendChild(imgBack);

            card.appendChild(faceFront); card.appendChild(faceBack);
            scene.appendChild(card);
            return scene;
        }
        function displayCards(cardIds) { /* ... (unchanged, closes modals) ... */
            if (isMemoryGameActive) closeMemoryGame();
            if (quizActive) closeQuiz();
            if (zoomOverlay.classList.contains('visible')) toggleZoom(null);

            initialView.style.display = 'none';
            cardDisplayArea.innerHTML = '';
            cardDisplayArea.style.display = 'flex';

            cardIds.forEach(id => {
                const cardData = cardsData.find(card => card.id === id);
                if (cardData) {
                    const cardElement = createCardElement(cardData);
                    cardDisplayArea.appendChild(cardElement);
                } else {
                    console.warn(\`Dados da carta não encontrados para ID: \${id}\`);
                }
            });
        }
         function toggleZoom(sceneElement) { /* ... (unchanged, checks modals) ... */
             if (isMemoryGameActive || quizActive) return; // Disable zoom if modals are open

            if (zoomOverlay.classList.contains('visible')) {
                zoomOverlay.classList.remove('visible');
                document.body.classList.remove('zoomed');
                setTimeout(() => { zoomOverlay.innerHTML = ''; }, 300);
            } else if (sceneElement) {
                zoomOverlay.innerHTML = '';
                const clonedScene = sceneElement.cloneNode(true);
                const clonedCard = clonedScene.querySelector('.card');
                const clonedZoomIcon = clonedScene.querySelector('.zoom-icon');

                if (clonedZoomIcon) {
                    clonedZoomIcon.textContent = '✖️';
                    clonedZoomIcon.addEventListener('click', (event) => {
                        event.stopPropagation();
                        toggleZoom(null);
                    });
                }
                if (clonedCard) {
                    clonedCard.style.cursor = 'pointer'; // Allow flipping in zoom
                    clonedCard.addEventListener('click', (event) => {
                        event.stopPropagation();
                        if (!event.target.classList.contains('zoom-icon')) { // Prevent flip on icon click
                           clonedCard.classList.toggle('is-flipped');
                        }
                    });
                }

                zoomOverlay.appendChild(clonedScene);
                document.body.classList.add('zoomed');
                void zoomOverlay.offsetWidth; // Trigger reflow
                zoomOverlay.classList.add('visible');
            }
        }
        function drawRandomCard() { displayCards([cardsData[Math.floor(Math.random() * cardsData.length)].id]); conditionSelect.value = ""; }
        function showConditionCards() { const selectedCondition = conditionSelect.value; if (selectedCondition && clinicalConditions[selectedCondition]) { const cardIds = clinicalConditions[selectedCondition]; displayCards(cardIds); } }
        function resetView() { /* ... (unchanged, closes modals) ... */
            if (isMemoryGameActive) closeMemoryGame();
            if (quizActive) closeQuiz();
            if (zoomOverlay.classList.contains('visible')) toggleZoom(null);

            cardDisplayArea.innerHTML = '';
            cardDisplayArea.style.display = 'none';
            initialView.style.display = 'flex';
            conditionSelect.value = "";
            document.body.classList.remove('memory-game-active', 'quiz-active', 'zoomed');
        }
        function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }

        // --- Funções do Quiz (Unchanged) ---
        function generateQuizQuestions() { /* ... (unchanged) ... */
            let generatedQuestions = []; const shuffledCards = shuffleArray([...cardsData]); const allCardNames = cardsData.map(card => card.name); const conditionNames = Object.keys(clinicalConditions);
            let imageQCount = 0; for (let i = 0; i < shuffledCards.length && imageQCount < QUESTIONS_PER_TYPE; i++) { const correctCard = shuffledCards[i]; const correctAnswerName = correctCard.name; const incorrectNames = allCardNames.filter(name => name !== correctAnswerName); shuffleArray(incorrectNames); const optionsAsStrings = [correctAnswerName, ...incorrectNames.slice(0, 3)]; if (optionsAsStrings.length < 4) continue; generatedQuestions.push({ question: "Qual o nome deste ponto?", image: correctCard.frontImage, options: shuffleArray(optionsAsStrings), correctAnswer: correctAnswerName }); imageQCount++; }
            let conditionQCount = 0; const shuffledConditions = shuffleArray([...conditionNames]); for (let i = 0; i < shuffledConditions.length && conditionQCount < QUESTIONS_PER_TYPE; i++) { const conditionName = shuffledConditions[i]; const possibleCorrectPointIds = clinicalConditions[conditionName]; if (!possibleCorrectPointIds || possibleCorrectPointIds.length === 0) continue; const correctPointId = possibleCorrectPointIds[Math.floor(Math.random() * possibleCorrectPointIds.length)]; const correctPointData = cardsData.find(card => card.id === correctPointId); if (!correctPointData) continue; const correctAnswerName = correctPointData.name; const correctOption = { name: correctAnswerName, image: correctPointData.frontImage }; const conditionPointNames = possibleCorrectPointIds.map(id => cardsData.find(card => card.id === id)?.name).filter(name => name); const incorrectNames = allCardNames.filter(name => !conditionPointNames.includes(name)); shuffleArray(incorrectNames); const incorrectOptions = incorrectNames.slice(0, 3).map(name => ({ name: name, image: cardImageMap.get(name) || PLACEHOLDER_IMAGE_URL })); if (incorrectOptions.length < 3) continue; const optionsAsObjects = shuffleArray([correctOption, ...incorrectOptions]); generatedQuestions.push({ question: \`Qual destes pontos é indicado para \${conditionName}?\`, image: null, options: optionsAsObjects, correctAnswer: correctAnswerName }); conditionQCount++; }
            while (generatedQuestions.length > 0 && generatedQuestions.length < TOTAL_QUIZ_QUESTIONS) { generatedQuestions.push({...generatedQuestions[Math.floor(Math.random() * generatedQuestions.length)]}); }
            quizQuestions = shuffleArray(generatedQuestions.slice(0, TOTAL_QUIZ_QUESTIONS));
        }
        function startQuiz() { /* ... (unchanged, closes modals) ... */
             if (isMemoryGameActive) closeMemoryGame();
             if (zoomOverlay.classList.contains('visible')) toggleZoom(null);
             quizActive = true;
             document.body.classList.add('quiz-active');
             initialView.style.display = 'none';
             cardDisplayArea.style.display = 'none';
             generateQuizQuestions();
             currentQuestionIndex = 0; score = 0; selectedAnswer = null;
             quizResultsEl.style.display = 'none';
             quizContentEl.style.display = 'block';
             quizModal.classList.add('visible');
             showQuestion();
        }
        function showQuestion() { /* ... (unchanged) ... */
             if (!quizQuestions || currentQuestionIndex >= quizQuestions.length) { showResults(); return; } const currentQ = quizQuestions[currentQuestionIndex]; quizQuestionEl.textContent = currentQ.question; quizImageContainerEl.innerHTML = ''; if (currentQ.image) { const img = document.createElement('img'); img.src = currentQ.image; img.alt = "Imagem do ponto"; img.onerror = () => { img.src = PLACEHOLDER_IMAGE_URL; img.alt = 'Erro ao carregar imagem'; }; quizImageContainerEl.appendChild(img); }
            quizOptionsEl.innerHTML = ''; currentQ.options.forEach(optionData => { const button = document.createElement('button'); button.classList.add('quiz-option-btn'); if (typeof optionData === 'string') { button.classList.add('no-image'); const text = document.createElement('span'); text.textContent = optionData; button.appendChild(text); button.dataset.optionValue = optionData; button.addEventListener('click', () => handleOptionSelect(button, optionData)); } else if (typeof optionData === 'object' && optionData !== null) { button.classList.add('has-image'); button.dataset.optionValue = optionData.name; const img = document.createElement('img'); img.src = optionData.image || PLACEHOLDER_IMAGE_URL; img.alt = optionData.name; img.onerror = () => { img.src = PLACEHOLDER_IMAGE_URL; img.alt = 'Erro img'; }; button.appendChild(img); const text = document.createElement('span'); text.textContent = optionData.name; button.appendChild(text); button.addEventListener('click', () => handleOptionSelect(button, optionData.name)); } quizOptionsEl.appendChild(button); });
            quizFeedbackEl.textContent = ''; quizFeedbackEl.className = 'quiz-feedback'; confirmAnswerBtn.disabled = true; nextQuestionBtn.style.display = 'none'; confirmAnswerBtn.style.display = 'inline-block'; updateScoreDisplay(); selectedAnswer = null;
        }
        function handleOptionSelect(button, optionName) { /* ... (unchanged) ... */ if (!quizActive) return; const allOptions = quizOptionsEl.querySelectorAll('.quiz-option-btn'); allOptions.forEach(btn => btn.classList.remove('selected')); button.classList.add('selected'); selectedAnswer = optionName; confirmAnswerBtn.disabled = false; }
        function checkAnswer() { /* ... (unchanged) ... */ if (!quizActive || selectedAnswer === null) return; const currentQ = quizQuestions[currentQuestionIndex]; const isCorrect = selectedAnswer === currentQ.correctAnswer; quizFeedbackEl.textContent = isCorrect ? 'Correto!' : \`Incorreto! A resposta era: \${currentQ.correctAnswer}\`; quizFeedbackEl.classList.add(isCorrect ? 'correct' : 'incorrect'); if (isCorrect) { score++; } const allOptions = quizOptionsEl.querySelectorAll('.quiz-option-btn'); allOptions.forEach(btn => { btn.disabled = true; const btnOptionValue = btn.dataset.optionValue; if (btnOptionValue === currentQ.correctAnswer) { btn.classList.add('correct'); } else if (btn.classList.contains('selected')) { btn.classList.add('incorrect'); } }); updateScoreDisplay(); confirmAnswerBtn.style.display = 'none'; nextQuestionBtn.style.display = 'inline-block'; }
        function nextQuestion() { /* ... (unchanged) ... */ if (!quizActive) return; currentQuestionIndex++; showQuestion(); }
        function updateScoreDisplay() { /* ... (unchanged) ... */ if (!quizActive) return; quizScoreEl.textContent = \`Pontuação: \${score} / \${quizQuestions.length || TOTAL_QUIZ_QUESTIONS}\`; }
        function showResults() { /* ... (unchanged) ... */ if (!quizActive) return; quizContentEl.style.display = 'none'; finalScoreEl.textContent = \`\${score} de \${quizQuestions.length}\`; quizResultsEl.style.display = 'block'; }
        function closeQuiz() { quizModal.classList.remove('visible'); document.body.classList.remove('quiz-active'); quizActive = false; }

        // --- Funções do Jogo da Memória ---

        // Opens the modal and shows the setup screen
        function openMemoryGameSetup() {
            if (quizActive) closeQuiz();
            if (zoomOverlay.classList.contains('visible')) toggleZoom(null);

            isMemoryGameActive = true; // Set flag early
            document.body.classList.add('memory-game-active');
            initialView.style.display = 'none'; // Hide other views
            cardDisplayArea.style.display = 'none';

            // Populate selector
            memoryPairsSelect.innerHTML = '';
            for (let i = 5; i <= cardsData.length; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                memoryPairsSelect.appendChild(option);
            }
            memoryPairsSelect.value = Math.min(10, cardsData.length); // Default to 10 or max available

             // Reset timer selection
            timerOptionsInputs.forEach((input, index) => input.checked = index === 0); // Check "Sem Tempo"

            // Reset modal state
            memoryGameContainer.classList.remove('maximized');
            toggleMaximizeMemoryBtn.textContent = '□';
            memoryGameSetup.style.display = 'flex';
            memoryGameArea.style.display = 'none';
            memoryGameArea.innerHTML = '';
            memoryGameStatusEl.textContent = 'Pares Encontrados: 0 / 0';
            memoryTimerDisplayEl.textContent = ''; // Clear timer display
            stopMemoryTimer(); // Ensure any previous timer is stopped

            // Show modal
            memoryGameModal.classList.add('visible');
        }

        // Initializes and displays the memory game board after setup
        function initMemoryGameBoard() {
            const numPairs = parseInt(memoryPairsSelect.value, 10);
            if (isNaN(numPairs) || numPairs < 5 || numPairs > cardsData.length) {
                alert("Número de pares inválido.");
                return;
            }

            // Get selected time
            const selectedTimerInput = document.querySelector('input[name="memoryTimer"]:checked');
            memorySelectedTime = parseInt(selectedTimerInput?.value || '0', 10); // Get time in seconds

            totalMemoryPairs = numPairs;
            lockBoard = false;
            flippedMemoryCards = [];
            matchedPairs = 0;
            memoryTimeLeft = memorySelectedTime; // Set initial time left

            memoryGameSetup.style.display = 'none';
            memoryGameArea.innerHTML = '';
            memoryGameArea.style.display = 'grid';

            updateMemoryStatus(); // Update status (pairs)
            updateMemoryTimerDisplay(); // Show initial time (or nothing if 0)

            // Create paired data
            let selectedCardsData = shuffleArray([...cardsData]).slice(0, totalMemoryPairs);
            let memoryGameData = [];
            selectedCardsData.forEach(card => {
                memoryGameData.push({ id: card.id, type: 'front', image: card.frontImage });
                memoryGameData.push({ id: card.id, type: 'back', image: card.backImage });
            });
            const shuffledMemoryData = shuffleArray(memoryGameData);

            // Create and append card elements
            shuffledMemoryData.forEach(cardInfo => {
                const memoryCardElement = createMemoryCardElement(cardInfo);
                memoryGameArea.appendChild(memoryCardElement);
            });

            // Start timer only if a time was selected
            if (memorySelectedTime > 0) {
                startMemoryTimer();
            }
        }

        function createMemoryCardElement(cardInfo) {
            const scene = document.createElement('div');
            scene.className = 'memory-scene';
            // Store data on the scene as well for easier removal
            scene.dataset.pointId = cardInfo.id;

            const card = document.createElement('div');
            card.className = 'memory-card';
            card.dataset.pointId = cardInfo.id;
            card.dataset.cardType = cardInfo.type;

            const faceFront = document.createElement('div');
            faceFront.className = 'memory-face memory-front';

            const faceBack = document.createElement('div');
            faceBack.className = 'memory-face memory-back';
            const imgBack = document.createElement('img');
            imgBack.src = cardInfo.image;
            imgBack.alt = \`Carta \${cardInfo.id} (\${cardInfo.type})\`;
            imgBack.onerror = () => { imgBack.src = PLACEHOLDER_IMAGE_URL; imgBack.alt = 'Erro imagem'; };
            faceBack.appendChild(imgBack);

            card.appendChild(faceFront);
            card.appendChild(faceBack);
            scene.appendChild(card);

            // Add click listener to the card, not the scene
            card.addEventListener('click', handleMemoryCardClick);
            return scene;
        }

        function handleMemoryCardClick(event) {
            if (!isMemoryGameActive || lockBoard) return;
            // Check if timer ran out (if applicable)
            if (memorySelectedTime > 0 && memoryTimeLeft <= 0) return;

            const clickedCard = event.currentTarget;
            // Prevent clicking already flipped or matched (disappearing) cards
            if (clickedCard.classList.contains('is-flipped') || clickedCard.closest('.memory-scene')?.classList.contains('matched-fade-out')) return;

            clickedCard.classList.add('is-flipped');
            flippedMemoryCards.push(clickedCard);

            if (flippedMemoryCards.length === 2) {
                lockBoard = true; // Lock board while checking
                checkForMatch();
            }
        }

        function checkForMatch() {
            const [card1, card2] = flippedMemoryCards;
            const isMatch = (card1.dataset.pointId === card2.dataset.pointId) && (card1.dataset.cardType !== card2.dataset.cardType);

            if (isMatch) {
                // Found a match!
                matchedPairs++;
                updateMemoryStatus(); // Update status immediately

                // Get parent scenes to remove them
                const scene1 = card1.closest('.memory-scene');
                const scene2 = card2.closest('.memory-scene');

                // Add fading class and remove after timeout
                scene1?.classList.add('matched-fade-out');
                scene2?.classList.add('matched-fade-out');

                setTimeout(() => {
                    scene1?.remove();
                    scene2?.remove();

                    // Check for win condition *after* removal animation might finish visually
                    if (matchedPairs === totalMemoryPairs) {
                        winGame();
                    } else {
                         // Unlock board only after removal attempt if game not won
                         lockBoard = false;
                    }
                }, 500); // Match CSS transition duration

                flippedMemoryCards = []; // Reset flipped cards immediately
                 // Don't unlock board yet, wait for timeout unless game is won

            } else {
                // No match, unflip after a delay
                setTimeout(unflipCards, 1000);
            }
        }

        function unflipCards() {
            flippedMemoryCards.forEach(card => {
                card.classList.remove('is-flipped');
            });
            flippedMemoryCards = [];
            lockBoard = false; // Unlock board after unflipping
        }

         function winGame() {
            stopMemoryTimer(); // Stop timer on win
            updateMemoryStatus(); // Final status update
            memoryGameStatusEl.textContent += ' - Jogo Completo!';
            lockBoard = true; // Keep board locked after win
            setTimeout(() => {
                alert('Parabéns! Você encontrou todos os pares!');
            }, 300); // Short delay after last cards fade
         }

         function timeUp() {
             stopMemoryTimer();
             lockBoard = true; // Lock board when time runs out
             memoryTimerDisplayEl.textContent = "Tempo Esgotado!";
             alert('Tempo esgotado! Tente novamente.');
             // Optionally flip all remaining cards or highlight pairs
         }

        function closeMemoryGame() {
            stopMemoryTimer(); // Make sure timer stops when closing
            memoryGameModal.classList.remove('visible');
            document.body.classList.remove('memory-game-active');
            isMemoryGameActive = false;
        }

        function toggleMaximizeMemoryGame() {
            memoryGameContainer.classList.toggle('maximized');
            if (memoryGameContainer.classList.contains('maximized')) {
                toggleMaximizeMemoryBtn.textContent = '❐';
                toggleMaximizeMemoryBtn.title = 'Restaurar Tamanho';
            } else {
                toggleMaximizeMemoryBtn.textContent = '□';
                toggleMaximizeMemoryBtn.title = 'Maximizar';
            }
        }

        // --- Funções do Cronômetro ---
        function startMemoryTimer() {
            stopMemoryTimer(); // Clear any existing timer first
            memoryTimeLeft = memorySelectedTime; // Reset to selected time
            updateMemoryTimerDisplay(); // Show initial time

            memoryTimerInterval = setInterval(() => {
                memoryTimeLeft--;
                updateMemoryTimerDisplay();

                if (memoryTimeLeft <= 0) {
                    timeUp(); // Call time up logic
                }
            }, 1000); // Update every second
        }

        function stopMemoryTimer() {
            clearInterval(memoryTimerInterval);
            memoryTimerInterval = null;
        }

        function updateMemoryTimerDisplay() {
             if (memorySelectedTime <= 0) {
                 memoryTimerDisplayEl.textContent = ''; // No timer display if none selected
                 return;
             }
             if (memoryTimeLeft < 0) memoryTimeLeft = 0; // Prevent negative display

            const minutes = Math.floor(memoryTimeLeft / 60);
            const seconds = memoryTimeLeft % 60;
            // Pad seconds with a leading zero if less than 10
            memoryTimerDisplayEl.textContent = \`Tempo: \${minutes}:\${seconds < 10 ? '0' : ''}\${seconds}\`;
        }

        function updateMemoryStatus() {
             memoryGameStatusEl.textContent = \`Pares Encontrados: \${matchedPairs} / \${totalMemoryPairs}\`;
        }

        // --- Inicialização e Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
             populateConditions();
             resetView();

             // Main Controls
             randomCardBtn.addEventListener('click', drawRandomCard);
             conditionSelect.addEventListener('change', showConditionCards);
             resetBtn.addEventListener('click', resetView);
             startQuizBtn.addEventListener('click', startQuiz);
             openMemoryGameBtn.addEventListener('click', openMemoryGameSetup);

             // Zoom Overlay
             zoomOverlay.addEventListener('click', (event) => { if (event.target === zoomOverlay) toggleZoom(null); });

             // Quiz Listeners (Unchanged)
             closeQuizBtn.addEventListener('click', closeQuiz);
             confirmAnswerBtn.addEventListener('click', checkAnswer);
             nextQuestionBtn.addEventListener('click', nextQuestion);
             restartQuizBtn.addEventListener('click', startQuiz);
             quizModal.addEventListener('click', (event) => { if (event.target === quizModal) closeQuiz(); });
             quizContainer.addEventListener('click', (event) => { event.stopPropagation(); });

             // Memory Game Listeners
             closeMemoryGameBtn.addEventListener('click', closeMemoryGame);
             toggleMaximizeMemoryBtn.addEventListener('click', toggleMaximizeMemoryGame);
             confirmMemorySetupBtn.addEventListener('click', initMemoryGameBoard); // Starts the actual game
             memoryGameModal.addEventListener('click', (event) => { if (event.target === memoryGameModal) closeMemoryGame(); });
             memoryGameContainer.addEventListener('click', (event) => { event.stopPropagation(); }); // Prevent closing by clicking inside
        });
    <\/script> {/* IMPORTANTE: Escapar a tag de fechamento */}

</body>
</html>
        `; // Fim da string acupunctureAppHTML

        // --- Lógica do Clique do Botão ---
        document.getElementById('launchAcupunctureButton').addEventListener('click', () => {
            // Definir características da nova janela
            const windowFeatures = 'width=1200,height=800,resizable=yes,scrollbars=yes,status=yes';
            // Abrir uma nova janela em branco
            const newWindow = window.open('', '_blank', windowFeatures);

            // Verificar se a janela foi aberta com sucesso (não bloqueada)
            if (newWindow) {
                newWindow.document.open();
                // Escrever todo o conteúdo HTML/CSS/JS da aplicação na nova janela
                newWindow.document.write(acupunctureAppHTML);
                newWindow.document.close();
                // Trazer a nova janela para frente
                newWindow.focus();
            } else {
                // Informar o usuário se a janela foi bloqueada
                alert('Não foi possível abrir a aplicação. Verifique se o seu bloqueador de pop-ups está desativado para este site.');
            }
        });
    </script>

</body>
</html>
